'use server';

import { unstable_noStore } from "next/cache";

export interface TranscriptSegment {
  text: string
  duration: number
  offset: number
}

// A more browser-friendly way to get transcripts using a direct API call
export async function getYoutubeTranscript(
  videoId: string,
  language?: string
): Promise<TranscriptSegment[]> {
  'use server'; // Ensure this runs on the server
  
  unstable_noStore(); // Prevent caching

  console.log(`Fetching transcript for video: ${videoId}`);
  
  try {
    // First, we need to get the caption track URL
    const videoPageUrl = `https://www.youtube.com/watch?v=${videoId}`;
    
    // Fetch the video page
    const response = await fetch(videoPageUrl, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        'Accept-Language': language || 'en-US,en'
      }
    });
    
    if (!response.ok) {
      throw new Error(`Failed to fetch video page: ${response.status}`);
    }
    
    const html = await response.text();
    
    // Extract caption track data
    const captionTrackRegex = /"captions":\s*{.*?"captionTracks":\s*(\[.*?\])/s;
    const match = html.match(captionTrackRegex);
    
    if (!match || !match[1]) {
      // Fallback to a simpler pattern if the first one fails
      const simpleCaptionRegex = /"captionTracks":\s*(\[.*?\])/s;
      const simpleMatch = html.match(simpleCaptionRegex);
      
      if (!simpleMatch || !simpleMatch[1]) {
        throw new Error('No captions found in this video');
      }
      
      match[1] = simpleMatch[1];
    }
    
    // Parse the caption tracks JSON
    let captionTracks: any[];
    try {
      captionTracks = JSON.parse(match[1]);
    } catch (error) {
      console.error('Failed to parse caption tracks:', error);
      throw new Error('Failed to parse caption data');
    }
    
    if (!captionTracks || !Array.isArray(captionTracks) || captionTracks.length === 0) {
      throw new Error('No caption tracks available');
    }
    
    // Find the appropriate caption track
    let selectedTrack = captionTracks[0]; // Default to first track
    
    if (language) {
      // Try to find exact match
      const langTrack = captionTracks.find(track => 
        track.languageCode?.toLowerCase() === language.toLowerCase() ||
        track.name?.simpleText?.toLowerCase().includes(language.toLowerCase())
      );
      
      if (langTrack) {
        selectedTrack = langTrack;
      }
    } else {
      // Try to find English or auto-generated English
      const engTrack = captionTracks.find(track => 
        track.languageCode === 'en' || track.vssId === 'a.en'
      );
      
      if (engTrack) {
        selectedTrack = engTrack;
      }
    }
    
    if (!selectedTrack.baseUrl) {
      throw new Error('Selected caption track has no URL');
    }
    
    // Fetch the actual transcript XML
    const transcriptResponse = await fetch(selectedTrack.baseUrl);
    if (!transcriptResponse.ok) {
      throw new Error(`Failed to fetch transcript: ${transcriptResponse.status}`);
    }
    
    const transcriptXML = await transcriptResponse.text();
    
    // Parse the XML on the server
    const segments: TranscriptSegment[] = [];
    
    // Try multiple regex patterns for better compatibility
    const regexPatterns = [
      /<text start="([\d.]+)" dur="([\d.]+)".*?>(.*?)<\/text>/g,
      /<text start="([\d.]+)" dur="([\d.]+)">(.*?)<\/text>/g,
      /<text[^>]*start="([\d.]+)"[^>]*dur="([\d.]+)"[^>]*>(.*?)<\/text>/g
    ];

    let foundSegments = false;

    for (const regex of regexPatterns) {
    let match2;
    
    while ((match2 = regex.exec(transcriptXML)) !== null) {
      const [_, startStr, durStr, text] = match2;
      
      // Parse start and duration as float
      const start = parseFloat(startStr);
      const dur = parseFloat(durStr);
      
      // Decode HTML entities
      const decodedText = text
        .replace(/&amp;/g, '&')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&quot;/g, '"')
        .replace(/&#39;/g, "'")
        .replace(/<[^>]*>/g, ''); // Remove any HTML tags
      
      segments.push({
        text: decodedText,
        duration: dur,
        offset: start
      });
    }
    
    if (segments.length === 0) {
      throw new Error('Failed to parse transcript data');
    }
    
    return segments;
    
  } catch (error) {
    console.error('Error fetching transcript:', error);
    throw error instanceof Error 
      ? error 
      : new Error('Unknown error while fetching transcript');
  }
}

// Helper functions in a client-safe format (not server actions)
// Remove the export to keep them private to this file
function formatTranscriptTime(seconds: number): string {
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = Math.floor(seconds % 60);
  return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
}

// Export client-safe wrapper functions
export async function formatTime(seconds: number): Promise<string> {
  'use server';
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = Math.floor(seconds % 60);
  return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
}

export async function findSegment(
  transcript: TranscriptSegment[],
  timeInSeconds: number
): Promise<TranscriptSegment | undefined> {
  'use server';
  return transcript.find(segment => {
    const start = segment.offset;
    const end = start + segment.duration;
    return timeInSeconds >= start && timeInSeconds < end;
  });
}

export async function getSegmentRange(
  transcript: TranscriptSegment[],
  startTime: number,
  endTime: number
): Promise<TranscriptSegment[]> {
  'use server';
  return transcript.filter(segment => {
    const segmentStart = segment.offset;
    const segmentEnd = segmentStart + segment.duration;
    return (segmentStart >= startTime && segmentStart < endTime) ||
           (segmentEnd > startTime && segmentEnd <= endTime) ||
           (segmentStart <= startTime && segmentEnd >= endTime);
  });
}

export async function searchInTranscript(
  transcript: TranscriptSegment[],
  query: string,
  fuzzy = false
): Promise<TranscriptSegment[]> {
  'use server';
  const searchTerm = query.toLowerCase();
  
  if (fuzzy) {
    // Fuzzy search implementation
    return transcript.filter(segment => {
      const words = searchTerm.split(' ');
      const text = segment.text.toLowerCase();
      return words.every(word => text.includes(word));
    });
  }
  
  // Exact match search
  return transcript.filter(segment => 
    segment.text.toLowerCase().includes(searchTerm)
  );
}
